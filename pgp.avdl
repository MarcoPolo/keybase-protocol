@namespace("keybase.1")

protocol pgp {
	import idl "common.avdl";

	enum SignMode {
		ATTACHED,
		DETACHED,
		CLEAR
	}

	record PgpSignOptions {
		string keyQuery;
		SignMode mode;
		boolean binaryIn;
		boolean binaryOut;
	}

	// Return a source that we should be writing to.
	void pgpSign(int sessionID, Stream source, Stream sink, PgpSignOptions opts);

	// Download PGP keys for tracked users and update the local GPG keyring.
	// If usernames is nonempty, update only those users.
	void pgpPull(int sessionID, array<string> userAsserts);

	record PgpEncryptOptions {
		array<string> recipients; // user assertions
		boolean noSign;
		boolean noSelf;
		boolean binaryOut;
		string keyQuery;
		boolean localOnly; // store track locally only
		boolean approveRemote;  // approve remote track without prompt
	}

	void pgpEncrypt(int sessionID, Stream source, Stream sink, PgpEncryptOptions opts);
	
	record PgpDecryptOptions {
		boolean assertSigned;
		boolean localOnly; // store track locally only
		boolean approveRemote;  // approve remote track without prompt
	}

	void pgpDecrypt(int sessionID, Stream source, Stream sink, PgpDecryptOptions opts);
	
	record PgpVerifyOptions {
		boolean localOnly; // store track locally only
		boolean approveRemote;  // approve remote track without prompt
		bytes signature; // detached signature data (binary or armored), can be empty
	}
	
	void pgpVerify(int sessionID, Stream source, PgpVerifyOptions opts);

	void pgpImport(int sessionID, bytes key, boolean pushSecret);

	record FingerprintAndKey {
		string fingerprint;
		string key;
		string desc;
	}

	// Exports all active PGP keys, public. Only allows armored export.
	// If you ask for private, you can get at most one key back.
	array<FingerprintAndKey> pgpExport(int sessionID, boolean secret, string query);
}
